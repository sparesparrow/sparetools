import anthropic

client = anthropic.Anthropic(
    # defaults to os.environ.get("ANTHROPIC_API_KEY")
    api_key="my_api_key",
)

# Replace placeholders like {{USER_REQUEST}} with real values,
# because the SDK does not support variables.
message = client.messages.create(
    model="claude-3-5-sonnet-20241022",
    max_tokens=1000,
    temperature=0,
    system="You are an AI assistant specialized in translating natural language requests into bash commands for Ubuntu Studio Linux with KDE desktop environment. Your task is to interpret user requests and provide the corresponding bash commands along with brief explanations.\n\nHere's the user's request:\n\n<user_request>\n{{USER_REQUEST}}\n</user_request>\n\nPlease follow these steps to process the request and generate a response:\n\n1. Analyze the request and identify the key components:\n   - Action to be performed\n   - Specific tools or services mentioned\n   - Parameters or conditions specified\n\n2. Formulate an appropriate bash script that fulfills the user's request, considering:\n   - Common Linux command-line tools and utilities\n   - Specific tools mentioned in the request (prioritize these)\n   - Necessary options or flags to achieve the desired outcome\n   - Combining multiple steps using appropriate bash syntax (e.g., functions, loops, or conditionals) if needed\n   - Including echo commands to communicate analysis content to the user\n   - Adding interactive elements where appropriate (e.g., user prompts, menus)\n\n3. Evaluate the safety of the script:\n   - Ensure the commands don't pose potential risks to the system\n   - If a request seems unsafe, prepare a warning and suggest a safer alternative\n\n4. Generate a JSON response with the following structure:\n   {\n     \"name\": \"descriptive_filename.sh\",\n     \"description\": \"Brief explanation of what the script does\",\n     \"script\": \"The actual bash script\"\n   }\n\n   Note: The \"name\" field should be a descriptive filename based on the script's function, ending with .sh\n\nBefore providing your final response, wrap your thought process inside <thinking> tags. This analysis should include:\na. A clear list of the key components identified in the user's request\nb. Consideration of multiple command options, explaining the reasoning for your final choice\nc. An evaluation of potential security risks and explanation of any mitigation strategies\nd. Your approach to making the script interactive and informative\ne. Consideration of potential edge cases or variations in the user's request\nf. Explicit consideration of the KDE desktop environment and Ubuntu Studio-specific tools\ng. A step-by-step breakdown of how you'll construct the bash script\n\nRemember to always prioritize security and avoid potentially harmful commands. If the user's request is unclear or too complex to be translated into a single bash script, explain the limitations in your analysis process and suggest breaking down the request into smaller, more manageable tasks.\n\nAfter your analysis, provide the JSON response as described above.",
    messages=[
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "<examples>\n<example>\n<USER_REQUEST>\nMonitor MIDI input from a USB MIDI controller\n</USER_REQUEST>\n<ideal_output>\n<thinking>\na. Key components identified:\n   - Action: Monitor MIDI input\n   - Specific tool: USB MIDI controller\n   - Parameters: None specified\n\nb. Command options:\n   1. aconnect -i: Lists MIDI input ports but doesn't monitor events.\n   2. amidi -d: Dumps raw MIDI data, not suitable for monitoring in a user-friendly format.\n   3. aseqdump: Provides real-time display of MIDI events in a human-readable format.\n\n   After considering these options, aseqdump seems most appropriate for monitoring MIDI input in a user-friendly way.\n\nc. Security evaluation:\n   aseqdump is safe to use as it only reads MIDI input without modifying system settings. No significant security risks are associated with this command.\n\nd. Interactivity and information:\n   The script will directly output MIDI events, providing real-time information without requiring additional interactivity.\n\ne. Edge cases:\n   - Multiple MIDI devices connected: We'll use the -p option to specify the device name.\n   - No MIDI device connected: We'll add an error check before running aseqdump.\n\nf. KDE and Ubuntu Studio consideration:\n   This command is not specific to KDE or Ubuntu Studio, but it's compatible with these environments.\n\ng. Script construction:\n   1. Check if aseqdump is installed\n   2. Verify MIDI device connectivity\n   3. Run aseqdump with appropriate options\n   4. Provide helpful output messages\n\nNow, I'll construct the JSON response based on this analysis.\n</thinking>\n\n{\n  \"name\": \"monitor_midi_input.sh\",\n  \"description\": \"Monitors MIDI input from a USB MIDI controller using aseqdump\",\n  \"script\": \"#!/bin/bash\\n\\n# Check if aseqdump is installed\\nif ! command -v aseqdump &> /dev/null; then\\n    echo \\\"Error: aseqdump is not installed. Please install it using 'sudo apt-get install alsa-utils'.\\\"\\n    exit 1\\nfi\\n\\n# Check if MIDI device is connected\\nif ! aconnect -i | grep -q 'USB MIDI Controller'; then\\n    echo \\\"Error: USB MIDI Controller not found. Please connect your device and try again.\\\"\\n    exit 1\\nfi\\n\\necho \\\"Monitoring MIDI input from USB MIDI Controller. Press Ctrl+C to stop.\\\"\\naseqdump -p \\\"USB MIDI Controller\\\"\\n\"\n}\n</ideal_output>\n</example>\n<example>\n<USER_REQUEST>\nCreate an SSH tunnel\n</USER_REQUEST>\n<ideal_output>\n<thinking>\na. Key components identified:\n   - Action: Create an SSH tunnel\n   - Specific tool: SSH\n   - Parameters: None specified (assumptions needed)\n\nb. Command options:\n   1. ssh -D: Creates a SOCKS proxy, not a typical SSH tunnel.\n   2. ssh -R: Creates a reverse tunnel, not commonly meant by \"SSH tunnel\".\n   3. ssh -L: Creates a local port forwarding tunnel, the most common type.\n\n   After consideration, ssh -L is most appropriate for creating a standard SSH tunnel.\n\nc. Security evaluation:\n   SSH tunnels encrypt traffic but have potential risks:\n   1. Trust in the remote host is crucial.\n   2. Local port conflicts should be avoided.\n   3. Users must understand this creates a potential entry point to their system.\n\n   To mitigate risks, we'll use a non-standard high port number and add checks.\n\nd. Interactivity and information:\n   We'll add prompts for user input to specify remote host, port, and local port.\n\ne. Edge cases:\n   - Local port already in use: We'll add a check and allow retry.\n   - SSH key authentication: We'll provide an option for this.\n\nf. KDE and Ubuntu Studio consideration:\n   This command is not specific to KDE or Ubuntu Studio but is fully compatible.\n\ng. Script construction:\n   1. Prompt for remote host, remote port, and local port\n   2. Check if local port is available\n   3. Offer SSH key authentication option\n   4. Construct and execute SSH command\n   5. Provide helpful output messages\n\nNow, I'll construct the JSON response based on this analysis.\n</thinking>\n\n{\n  \"name\": \"create_ssh_tunnel.sh\",\n  \"description\": \"Creates an SSH tunnel with user-specified parameters and security checks\",\n  \"script\": \"#!/bin/bash\\n\\necho \\\"SSH Tunnel Creator\\\"\\n\\nread -p \\\"Enter remote host: \\\" remote_host\\nread -p \\\"Enter remote port: \\\" remote_port\\nread -p \\\"Enter local port (default 8022): \\\" local_port\\nlocal_port=${local_port:-8022}\\n\\n# Check if local port is available\\nif ss -tln | grep -q :$local_port; then\\n    echo \\\"Error: Local port $local_port is already in use.\\\"\\n    exit 1\\nfi\\n\\nread -p \\\"Use SSH key authentication? (y/n): \\\" use_key\\n\\nif [ \\\"$use_key\\\" = \\\"y\\\" ]; then\\n    ssh_command=\\\"ssh -i ~/.ssh/id_rsa -L $local_port:localhost:$remote_port $remote_host\\\"\\nelse\\n    ssh_command=\\\"ssh -L $local_port:localhost:$remote_port $remote_host\\\"\\nfi\\n\\necho \\\"Creating SSH tunnel...\\\"\\necho \\\"Local port $local_port will be forwarded to port $remote_port on $remote_host\\\"\\necho \\\"Press Ctrl+C to stop the tunnel\\\"\\n\\n$ssh_command\\n\"\n}\n</ideal_output>\n</example>\n<example>\n<USER_REQUEST>\nCheck recent journalctl errors\n</USER_REQUEST>\n<ideal_output>\n<thinking>\na. Key components identified:\n   - Action: Check recent errors\n   - Specific tool: journalctl\n   - Parameters: Recent, errors\n\nb. Command options:\n   1. journalctl -xe: Shows journal end, not ideal for recent errors.\n   2. journalctl -f: Follows journal real-time, not suitable for checking recent errors.\n   3. journalctl -p err..emerg: Filters error to emergency priority levels.\n\n   After analysis, combining journalctl -p err..emerg with -n for recent entries is most appropriate.\n\nc. Security evaluation:\n   This command only reads from the system journal without modifications. However, output may contain sensitive information, so we'll add a warning.\n\nd. Interactivity and information:\n   We'll add an option for the user to specify the number of recent entries to display.\n\ne. Edge cases:\n   - No recent errors: We'll add a check and inform the user if no errors are found.\n   - Very large number of errors: We'll add a confirmation prompt for large outputs.\n\nf. KDE and Ubuntu Studio consideration:\n   While not specific to KDE or Ubuntu Studio, this command works in these environments and can help troubleshoot system issues.\n\ng. Script construction:\n   1. Prompt user for number of entries to display\n   2. Add confirmation for large number of entries\n   3. Execute journalctl command with appropriate options\n   4. Check for empty output and inform user if no errors found\n   5. Display a warning about potential sensitive information in output\n\nNow, I'll construct the JSON response based on this analysis.\n</thinking>\n\n{\n  \"name\": \"check_recent_journalctl_errors.sh\",\n  \"description\": \"Checks and displays recent journalctl errors with user-specified entry count\",\n  \"script\": \"#!/bin/bash\\n\\necho \\\"Recent Journalctl Errors Checker\\\"\\n\\nread -p \\\"Enter the number of recent entries to check (default 50): \\\" num_entries\\nnum_entries=${num_entries:-50}\\n\\nif [ $num_entries -gt 1000 ]; then\\n    read -p \\\"You've requested a large number of entries. This may take a while and produce a lot of output. Continue? (y/n): \\\" confirm\\n    if [ \\\"$confirm\\\" != \\\"y\\\" ]; then\\n        echo \\\"Operation cancelled.\\\"\\n        exit 0\\n    fi\\nfi\\n\\necho \\\"Checking the last $num_entries journalctl entries for errors...\\\"\\necho \\\"Warning: The output may contain sensitive system information.\\\"\\n\\noutput=$(journalctl -p err..emerg -n $num_entries --no-pager)\\n\\nif [ -z \\\"$output\\\" ]; then\\n    echo \\\"No errors found in the last $num_entries entries.\\\"\\nelse\\n    echo \\\"$output\\\"\\nfi\\n\"\n}\n</ideal_output>\n</example>\n<example>\n<USER_REQUEST>\nMonitor and replay input\n</USER_REQUEST>\n<ideal_output>\n<thinking>\na. Key components identified:\n   - Action 1: Monitor input\n   - Action 2: Replay input\n   - Specific tools: Not specified (need to choose appropriate tools)\n   - Parameters: None specified (assumptions needed)\n\nb. Command options:\n   For monitoring:\n   1. xinput: Provides detailed input device information and event monitoring.\n   2. evtest: Monitors input device events but requires root privileges.\n   3. xev: Monitors X events but limited to a specific window.\n\n   For replaying:\n   1. xdotool: Can simulate keyboard and mouse input events.\n   2. xte: Part of xautomation package, for simple event replay.\n   3. autokey: Complex scripting tool for input automation.\n\n   After analysis, xinput for monitoring and xdotool for replaying are most suitable.\n\nc. Security evaluation:\n   Potential security implications:\n   1. Captures all input, including sensitive data like passwords.\n   2. Replay script could execute harmful commands if malicious input is captured.\n\n   To mitigate risks:\n   1. Limit monitoring time.\n   2. Filter captured input to include only key and button press events.\n   3. Warn user to review replay script before execution.\n\nd. Interactivity and information:\n   We'll add prompts for monitoring duration and review options before replay.\n\ne. Edge cases:\n   - No input detected: Add a check and inform the user.\n   - Very long input sequence: Add a confirmation for long replay scripts.\n\nf. KDE and Ubuntu Studio consideration:\n   These tools work in KDE and Ubuntu Studio environments. We'll check for required packages.\n\ng. Script construction:\n   1. Check for required tools (xinput, xdotool)\n   2. Prompt for monitoring duration\n   3. Monitor input using xinput\n   4. Filter and process captured input\n   5. Generate replay script\n   6. Offer review and execution options\n\nNow, I'll construct the JSON response based on this analysis.\n</thinking>\n\n{\n  \"name\": \"monitor_and_replay_input.sh\",\n  \"description\": \"Monitors input events and creates a script to replay them, with security considerations\",\n  \"script\": \"#!/bin/bash\\n\\necho \\\"Input Monitor and Replay Tool\\\"\\n\\n# Check for required tools\\nfor tool in xinput xdotool; do\\n    if ! command -v $tool &> /dev/null; then\\n        echo \\\"Error: $tool is not installed. Please install it and try again.\\\"\\n        exit 1\\n    fi\\ndone\\n\\nread -p \\\"Enter monitoring duration in seconds (default 10): \\\" duration\\nduration=${duration:-10}\\n\\necho \\\"Monitoring input for $duration seconds...\\\"\\ntimeout ${duration}s xinput test-xi2 --root > input_log.txt\\n\\nif [ ! -s input_log.txt ]; then\\n    echo \\\"No input detected during the monitoring period.\\\"\\n    exit 0\\nfi\\n\\necho \\\"Creating replay script...\\\"\\necho '#!/bin/bash' > replay_script.sh\\necho \\\"xdotool type $(cat input_log.txt | grep -E 'key press|button press' | awk '{print $NF}')\\\" >> replay_script.sh\\nchmod +x replay_script.sh\\n\\necho \\\"Replay script created as replay_script.sh\\\"\\necho \\\"Warning: Review the script content before executing to ensure it's safe.\\\"\\n\\nread -p \\\"Do you want to review the replay script? (y/n): \\\" review\\nif [ \\\"$review\\\" = \\\"y\\\" ]; then\\n    less replay_script.sh\\nfi\\n\\nread -p \\\"Do you want to execute the replay script now? (y/n): \\\" execute\\nif [ \\\"$execute\\\" = \\\"y\\\" ]; then\\n    echo \\\"Executing replay script in 5 seconds. Focus on the desired window.\\\"\\n    sleep 5\\n    ./replay_script.sh\\nelse\\n    echo \\\"You can execute the script later by running: ./replay_script.sh\\\"\\nfi\\n\"\n}\n</ideal_output>\n</example>\n</examples>\n\n"
                },
                {
                    "type": "text",
                    "text": "one of docker containers provides VNC server. i need to connect to VNC trough SSH\nContainer Network Details\nNetwork: ha_bridge_network (172.21.0.0/16)\nContainer IP: 172.21.0.3\nExposed ports: 5900(VNC), 6080(noVNC), 8501(Streamlit), 22(SSH)\n"
                }
            ]
        }
    ]
)
print(message.content)
